<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root">
    <div>
      <div>
        <p>{{name}}--{{message}}</p>
      </div>
    </div>
    <p>{{name}}</p>
    <p>{{message}}</p>
  </div>

  <script>
    /**
     *  步骤拆解
     *    1.拿到模板
     *    2.拿到数据 (data)
     *    3.将数据与模板结合，得到的 是 HTML 元素 ( DOM元素 )
     */
    let rkuohao = /\{\{(.+?)\}\}/g;  //  .+ 标示匹配任意字符 ？取值贪婪
    // 1.
    let tempNode = document.querySelector('#root');
    // 2.
    let data = { name: '水水水水水', message: '消息' }; 
    // 3.将数据放到模板中
    //  一般都是使用 递归
    //  在现在这个案例中 template 是 DOM 元素
    //  在真正的 Vue 源码中是 DOM  -> 字符串模板 -> VNode -> 真正的 DOM
    function complier(template, data) {
      //  取出子元素
      let childNodes = template.childNodes;
      for(let i = 0; i < childNodes.length; i ++) {
        //  1. 元素 / 3. 文本节点
        let type = childNodes[i].nodeType;

        if (type === 1) {
          //  元素，考虑它有没有子元素，是否需要将其子元素进行 判断是否要差值
          complier(childNodes[i], data);
        } else if(type === 3) {
          //  文本节点，可以判断里面是否有 {{}} 差值

          //  该属性只有文本节点才有意义
          let txt = childNodes[i].nodeValue;

          //  判断是否有花括号
          txt = txt.replace(rkuohao, (_, g1) => {
            //  第一个参数表示 匹配到的数据
            //  函数的 第 n 个参数 标示正则中的 第 n 组
            //  函数返回值替换 匹配到的数据

            let key = g1.trim();
            let value = data[key];
            //  将 {{xxx}} 用这个值替换
            return value;
          })
          childNodes[i].nodeValue = txt;
        }
      }
    }
    let generateNode = tempNode.cloneNode(true);
    complier(generateNode, data);
    //  4.
    root.parentNode.replaceChild(generateNode, root);

    /**
     *  上面的思路有很大的问题：
     *    1. Vue 使用的 虚拟 Dom
     *    2. 值考虑了 单属性 ( {{name}} ), 而 Vue 中大量的使用层级 ( {{ child.name.nmae }} )
     *    3. 代码整合
     */
  </script>
</body>
</html>