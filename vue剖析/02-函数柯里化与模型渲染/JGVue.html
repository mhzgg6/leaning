<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root" title='标题' class="test">
    <div class="a">
      <div>{{name}}</div>
      <div title="ss">{{age}}</div>
      <div>{{age}}</div>
      <ul>
        <li class="bb">1</li>
        <li>2</li>
        <li>3</li>
      </ul>
    </div>
  </div>

  <script>
    /** 虚拟 DOM 构造函数 */
    class VNode {
      constructor(tag, data, value, type) {
        this.tag = tag;
        this.data = data;
        this.value = value;
        this.type = type;
        this.children = [];
      }

      appendChild(vnode) {
        this.children.push(vnode);
      }
    }

    /** 由 HTML DOM -> VNode: 将这个函数当作 compiler 函数 */
    function getVNode(node) {
      let { nodeType } = node;
      let _vnode = null;
      if (nodeType === 1) {
        //  元素
        let { nodeName, attributes } = node;
        let _attrObj = {};
        //  attributes { 0: id, 1: title, 2: class } ==> 所有属性的伪数组
        for (let i = 0; i < attributes.length; i ++) {// attributes[i] 属性节点 
          // attributes[i] => title="标题"    attributes[i].nodeName => 'title'
          _attrObj[attributes[i].nodeName] = attributes[i].nodeValue;
        }
        _vnode = new VNode(nodeName, _attrObj, undefined, nodeType);

        //  考虑 node 子元素
        let childNodes = node.childNodes;
        for (let i = 0; i < childNodes.length; i ++) {
          _vnode.appendChild(getVNode(childNodes[i])); // 递归
        }
      } else if (nodeType === 3) {
        _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType);
      } 
      return _vnode;
    }

    let rkuohao = /\{\{(.+?)\}\}/;

    /**  根据路径 访问对象成员 */
    function getValueByPath(obj, path) {
      //  [xxx, yyy, zzz]
      let paths = path.split('.');      
      let res = obj;
      let prop;
      while(prop = paths.shift()) {
        res = res[prop];
      }
      return res;
    }

    /** 将带有坑的 VNode 与 数据 结合，得到填充数据的 VNode：模拟 AST -> VNode */
    function combine(vnode, data) {
      let _type = vnode.type;
      let _data = vnode.data;
      let _value = vnode.value;
      let _tag = vnode.tag;
      let _children = vnode.children;

      let _vnode = null;
       
      if (_type === 3) {//  文本节点

        //  对文本进行处理
        _value = _value.replace(rkuohao, function(_, g) {
          return getValueByPath(data, g.trim());
        })

        _vnode = new VNode(_tag, _data, _value, _type);
      } else if (_type === 1) {// 元素节点
        _vnode = new VNode(_tag, _data, _value, _type);
        _children.forEach(_subvnode => _vnode.appendChild(combine(_subvnode, data)));
      }
      return _vnode;
    }

    class JGVue{
      constructor(options) {
        this._data = options.data;
        this._template = document.querySelector(options.el);

        this.mount();// 挂载
      }

      mount() {
        //  需要提供一个 render 方法：生成虚拟 dom
        this.render = this.createRenderFn();

        this.mountComponent();
      }

      mountComponent() {
        //  执行 mountComponent 函数
        let mount = () => {
          this.update(this.render())
        }
        mount.call(this); //  本质应该交给 watcher 函数
      }

      /**
       *  再真正 Vue 中使用了 二次提交的 设计结构
       *  1.在页面中的 DOM 和 虚拟 DOM 是一一对应的关系
       *  2.先有 AST 数据生成 VNode （新 render ）
       *  3.将 旧的 VNode 和 新的 VNode 比较（diff），更新（update）
       */

      //  这里是生成 render 函数，目的是缓存 抽象语法树（目前使用虚拟 DOM 模拟）
      createRenderFn() {
        let ast = getVNode(this._template);
        //  vue: 将 AST + data => VNode
        //  暂时： 带有 坑 的 VNode + data => 含有数据的 VNode  
        return function render() {
          let tmp = combine(ast, this._data);
          debugger
          return tmp;
        }
      }

      //  将虚拟 DOM 渲染到页面中：diff 算法就在这里  
      update() {

      }
    }

    let app = new JGVue({
      el: '#root',
      data: {
        name: 'mao',
        age: 18
      }
    })
  </script>
</body>
</html>