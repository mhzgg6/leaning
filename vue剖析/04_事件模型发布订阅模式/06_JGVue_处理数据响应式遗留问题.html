<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root" title='标题' class="test">
    <div class="a">
      <div>{{name}}</div>
      <div title="ss">{{age}}</div>
      <div>{{age}}</div>
      <ul>
        <li class="bb">1</li>
        <li>2</li>
        <li>3</li>
      </ul>
    </div>
  </div>

  <script>
    //  数组修改原型方法
    let ARRAY_METHOD = [
      'push',
      'pop',
      'shift',
      'unshift',
      'reverse',
      'sort',
      'splice'
    ];
    let array_method = Object.create( Array.prototype );
    ARRAY_METHOD.forEach((method) => {
      array_method[method] = function () {
        //  将数据进行响应式化
        for(let i = 0; i < arguments.length; i ++) {
          reactify(arguments[i]);
        }

        //  调用原来的方法
        let res = Array.prototype[method].apply(this, arguments);
        return res;
      }
    })

    function defineReactive(target, key, value, enumerable) {
      //  折中处理后 this 就是 vue 实例  
      let that = this;

      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        //  非数组的引用类型
        reactify(value);  //  递归
      }

      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: !!enumerable,
        get() {
          return value;
        },
        set(newVal) {
          value = reactify(newVal);

          //  模板刷新（现在是假的，只是演示）
          //  vue 实例  watcher 就不会有这个问题
          that.mountComponent();
        }
      })
    }

    //  将对象 o 响应化
    function reactify(o, vm) {
      let keys = Object.keys(o);

      for(let i = 0; i < keys.length; i ++) {
        let key = keys[i];
        let value = o[key];

        //  判断值是否为 数组 / 引用类型
        //  引用类型 用递归 
        if (Array.isArray(value)) {
          //  数组
          for(let j = 0; j < value.length; j ++) {
            value.__proto__ = array_method;// 数组响应式
            reactify(value[j], vm);
          }
        } else {
          //  对象或者值类型
          defineReactive.call(vm, o, key, value, true);
        }

      }
    }
    
    //  取代原来 reactify 方法  将对象转为响应式
    function observer(obj) {

    }
    
    /** 虚拟 DOM 构造函数 */
    class VNode {
      constructor(tag, data, value, type) {
        this.tag = tag;
        this.data = data;
        this.value = value;
        this.type = type;
        this.children = [];
      }

      appendChild(vnode) {
        this.children.push(vnode);
      }
    }

    /** 由 HTML DOM -> VNode: 将这个函数当作 compiler 函数 */
    function getVNode(node) {
      let { nodeType } = node;
      let _vnode = null;
      if (nodeType === 1) {
        //  元素
        let { nodeName, attributes } = node;
        let _attrObj = {};
        //  attributes { 0: id, 1: title, 2: class } ==> 所有属性的伪数组
        for (let i = 0; i < attributes.length; i ++) {// attributes[i] 属性节点 
          // attributes[i] => title="标题"    attributes[i].nodeName => 'title'
          _attrObj[attributes[i].nodeName] = attributes[i].nodeValue;
        }
        _vnode = new VNode(nodeName, _attrObj, undefined, nodeType);

        //  考虑 node 子元素
        let childNodes = node.childNodes;
        for (let i = 0; i < childNodes.length; i ++) {
          _vnode.appendChild(getVNode(childNodes[i])); // 递归
        }
      } else if (nodeType === 3) {
        _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType);
      } 
      return _vnode;
    }

    let rkuohao = /\{\{(.+?)\}\}/;

    /**  根据路径 访问对象成员 */
    function getValueByPath(obj, path) {
      //  [xxx, yyy, zzz]
      let paths = path.split('.');      
      let res = obj;
      let prop;
      while(prop = paths.shift()) {
        res = res[prop];
      }
      return res;
    }

    /** 将带有坑的 VNode 与 数据 结合，得到填充数据的 VNode：模拟 AST -> VNode */
    function combine(vnode, data) {
      let _type = vnode.type;
      let _data = vnode.data;
      let _value = vnode.value;
      let _tag = vnode.tag;
      let _children = vnode.children;

      let _vnode = null;
       
      if (_type === 3) {//  文本节点

        //  对文本进行处理
        _value = _value.replace(rkuohao, function(_, g) {
          return getValueByPath(data, g.trim());
        })

        _vnode = new VNode(_tag, _data, _value, _type);
      } else if (_type === 1) {// 元素节点
        _vnode = new VNode(_tag, _data, _value, _type);
        _children.forEach(_subvnode => _vnode.appendChild(combine(_subvnode, data)));
      }
      return _vnode;
    }

    //  将 vNode 转化为真正的 DOM
    function parseVNode(vnode) {
      let nodeName = vnode.tag && vnode.tag.toLowerCase();
      let { type, data } = vnode;
      let _vnode = null;
      if (type === 1) {
        _vnode = document.createElement(nodeName);
        Object.keys(data).forEach(key => {
          _vnode.setAttribute(key, data[key]);
        });

        let childNodes = vnode.children;
        childNodes.forEach((subvnode) => {
          _vnode.appendChild(parseVNode(subvnode));
        })
        return _vnode;
      } else if (type === 3) {
        return document.createTextNode(vnode.value);
      }
    }

    class JGVue{
      constructor(options) {
        this._data = options.data;
        let elm = document.querySelector(options.el);
        this._template = elm;
        this._parent = elm.parentNode;

        //  将数据响应式
        reactify(this._data, this /* 将 this 实例传入，折中处理 目前 */);

        this.mount();// 挂载
      }

      mount() {
        //  需要提供一个 render 方法：生成虚拟 dom
        this.render = this.createRenderFn();

        this.mountComponent();
      }

      mountComponent() {
        //  执行 mountComponent 函数
        let mount = () => {
          this.update(this.render())
        }
        mount.call(this); //  本质应该交给 watcher 函数
      }

      /**
       *  再真正 Vue 中使用了 二次提交的 设计结构
       *  1.在页面中的 DOM 和 虚拟 DOM 是一一对应的关系
       *  2.先有 AST 数据生成 VNode （新 render ）
       *  3.将 旧的 VNode 和 新的 VNode 比较（diff），更新（update）
       */

      //  这里是生成 render 函数，目的是缓存 抽象语法树（目前使用虚拟 DOM 模拟）
      createRenderFn() {
        let ast = getVNode(this._template);
        //  vue: 将 AST + data => VNode
        //  暂时： 带有 坑 的 VNode + data => 含有数据的 VNode  
        return function render() {
          let tmp = combine(ast, this._data);
          return tmp;
        }
      }

      //  将虚拟 DOM 渲染到页面中：diff 算法就在这里  
      update(vnode) {
        //  简化，直接生成 HTML_DOM repalceChild 到页面中
        //  父元素.repalceChild(新元素，旧元素)
        let realDom  = parseVNode(vnode);
        this._parent.replaceChild(realDom, document.querySelector('#root'));
        //  这个算法 每次会将页面中 DOM 全部替换
      }

      initData() {
        //  遍历 this._data 的成员 将属性转换为响应式  将直接属性 代理到实例上 
        let keys = Object.keys(this._data);

        //  响应式化
        for(let i = 0; i < keys.length; i ++) {
          //  这里将 对象  this._data[keys[i]] 变成响应式的
        }
        //  代理
        for(let i = 0; i < keys.length; i ++) {
          //  将 this._data[keys[i]] 映射 到 this[keys[i]] 上
        }
      }
    }

    let app = new JGVue({
      el: '#root',
      data: {
        name: 'mao',
        age: 19
      }
    })
  </script>
</body>
</html>